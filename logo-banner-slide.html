<style>
  .logo-banner {
    width: 100%;
    overflow: hidden;
    background-color: {{property.backgroundColor}};
    padding: {{property.paddingY}}px {{property.paddingX}}px;
    position: relative;
  }

  .logo-track {
    display: flex;
    align-items: center;
    gap: {{property.logoSpacing}}px;
    width: max-content;
    animation: scroll-{{property.direction}} {{property.speed}}s linear infinite;
  }

  .logo-item {
    flex-shrink: 0;
    height: {{property.logoHeight}}px;
    display: flex;
    align-items: center;
    justify-content: center;
    filter: grayscale({{property.grayscale}}%);
    opacity: {{property.opacity}};
    transition: all 0.3s ease;
    min-width: 120px;
  }

  .logo-item:hover {
    filter: grayscale(0%);
    opacity: 1;
    transform: scale(1.05);
  }

  .logo-item img {
    max-height: 100%;
    max-width: 200px;
    object-fit: contain;
    width: auto;
  }

  /* 정확한 무한 루프 애니메이션 - 50% 이동 */
  @keyframes scroll-left {
    from {
      transform: translateX(0);
    }
    to {
      transform: translateX(-50%);
    }
  }

  @keyframes scroll-right {
    from {
      transform: translateX(-50%);
    }
    to {
      transform: translateX(0);
    }
  }

  /* 마우스 호버 시 애니메이션 일시정지 */
  .logo-banner:hover .logo-track {
    animation-play-state: {{property.pauseOnHover}};
  }

  /* 반응형 디자인 */
  @media (max-width: 768px) {
    .logo-banner {
      padding: {{property.mobilePaddingY}}px {{property.mobilePaddingX}}px;
    }

    .logo-item {
      height: {{property.mobileLogoHeight}}px;
      min-width: 100px;
    }

    .logo-track {
      gap: {{property.mobileLogoSpacing}}px;
      animation: scroll-{{property.direction}} {{property.mobileSpeed}}s linear infinite;
    }
  }

  /* 애니메이션 성능 최적화 - GPU 가속 활성화 */
  .logo-track {
    transform: translateZ(0);
    backface-visibility: hidden;
  }
</style>

<template>
  <div class="logo-banner">
    <div class="logo-track" data-logo-track>
      <!-- 원본 로고 세트 -->
      {{#each property.logos}}
        <div class="logo-item" data-logo-item>
          <img
            src="{{image}}"
            alt="{{name}}"
            loading="lazy"
            onerror="this.src='https://ss3-prod-static-files.s3.ap-northeast-2.amazonaws.com/block-image-library/lifestyle/image1.jpg'"
          >
        </div>
      {{/each}}
    </div>
  </div>
</template>

<script>
  const container = bm.container;
  const track = container.querySelector('[data-logo-track]');

  // 무한 스크롤을 위한 동적 복제 함수
  function setupInfiniteScroll() {
    if (!track) return;

    // 원본 로고 아이템들 가져오기
    const logoItems = Array.from(track.querySelectorAll('[data-logo-item]'));
    if (logoItems.length === 0) return;

    // 이미지 로딩 완료 대기
    const images = track.querySelectorAll('img');
    const imagePromises = Array.from(images).map(img => {
      if (img.complete) return Promise.resolve();
      return new Promise(resolve => {
        img.onload = resolve;
        img.onerror = resolve;
      });
    });

    Promise.all(imagePromises).then(() => {
      // 컨테이너와 트랙의 실제 너비 측정
      const containerWidth = container.offsetWidth;
      const originalTrackWidth = track.scrollWidth;

      // 화면 너비의 최소 2배를 보장하기 위해 필요한 복제 횟수 계산
      // 여유를 위해 3배로 설정하여 완전히 끊김 없는 애니메이션 보장
      const minWidth = containerWidth * 3;
      const copiesNeeded = Math.ceil(minWidth / originalTrackWidth);

      // 원본을 포함해서 최소 2세트는 보장 (copiesNeeded가 1이면 1번 더 복제)
      const actualCopies = Math.max(copiesNeeded, 2);

      // 기존 복제본 제거 (원본만 남김)
      const existingItems = track.querySelectorAll('[data-logo-item]');
      existingItems.forEach((item, index) => {
        if (index >= logoItems.length) {
          item.remove();
        }
      });

      // 필요한 만큼 복제
      for (let i = 1; i < actualCopies; i++) {
        logoItems.forEach(item => {
          const clone = item.cloneNode(true);
          track.appendChild(clone);
        });
      }
    });
  }

  // 초기 실행
  setupInfiniteScroll();

  // 컨텍스트 변경 시 재실행
  if (bm.onContextChange) {
    bm.onContextChange = () => {
      setTimeout(setupInfiniteScroll, 100);
    };
  }

  // 윈도우 리사이즈 시 재계산
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(setupInfiniteScroll, 300);
  });
</script>
